### 题目描述

给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 *n* = 3，生成结果为:

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

给出 *n* = 2, 生成结果为:

```
[
	"(())",
	"()()"
]
```



### 解题思路

`LeetCode`里有很多种解题思路: 回溯、动态规划等等.

在这里我主要讲解一种最简单最好理解的方法.

思路:

1. 输入*n*, 则就表示会有*n*个左括号和*n*个右括号;
2. 使用递归的方式, 用两个变量`l`和`r`分别记录使用了左括号的数量和右括号的数量;
3. 当`l`小于`n`的时候, 则添加上左括号`(`, 且后面添加的右括号`)`都不能大于`l`.



### Coding

```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    let res = [];
    let cycle = (currentStr, l, r) => {
        if (l === n && r === n) { // 当左右括号数量和n相等则返回
            res.push(currentStr);
            return;
        }
        if (l < n) { // 若左括号的数量小于n
            cycle(currentStr + '(', l + 1, r);
        }
        if (l > r) { // 若左括号的数量大于右括号数量
            cycle(currentStr + ')', l, r + 1);
        }
    };
    cycle('', 0, 0);
    return res;
};
```

执行用时: **60ms**, 内存消耗: **35.2MB**.

