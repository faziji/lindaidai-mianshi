### 前言
首先在编写这篇文章之前呢，我想先澄清一些事情。
这篇文章是我参考阮一峰老师的《TCP协议简介》,仅仅是把它用我自己的话阐述一遍，以便自己以及一些想了解TCP协议的读者来理解。
有写的不好的或者表述不清楚的地方，请各位读者能指正出来，谢谢。

### 一、TCP存在哪里
介绍TCP之前，应该先要让大家了解一下TCP存在哪里并且有什么作用。

用一张图来表述可能更加实在

![](https://user-gold-cdn.xitu.io/2017/12/1/1600ff3a7cac6467?w=250&h=413&f=png&s=8121)

首先，可以看到，TCP是以太网协议和IP协议的上层协议，也是应用层的下层协议。

(简单介绍一下以太网协议和IP协议)

以太网协议：

最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。

IP协议：

IP协议解决的就是多个局域网互相通信，比如路由器就是基于IP协议的。

(通俗一点理解就是以太网协议解决了局域网的点对点通信，但不能解决多个局域网互相通信，这时候就得靠IP协议来解决多个局域网互相通信的问题)

那么弄清楚了这俩个协议之后好像还是不知道TCP到底在哪里。
别急，下面这张图更加实在。


![](https://user-gold-cdn.xitu.io/2017/12/1/1600ffd9f3f991d9?w=745&h=254&f=png&s=15960)

可以看到，不管是IP数据包还是TCP数据包还是应用层数据包都包裹在以太网数据包中的。

这个最大的以太网数据包最初只有1518字节，后来增加到了1522字节。

其中有1500字节是以太网数据包的负载，而另外的22字节是头信息。

![](https://user-gold-cdn.xitu.io/2017/12/1/1601014ad180d27a?w=976&h=278&f=png&s=5777)
(CRC是利用除法及余数的原理来作错误侦测)

那么所以另外的那些包数据都是存在于以太网的负载中的。

IP数据包又分为IP标头和IP负载，存在于以太网的负载中。
IP标头(也就是头信息)最少需要20字节，所以它的负载最多就是1500-20=1480字节。

TCP数据包又分为TCP标头和TCP负载，存在于IP数据包中。
TCP标头(也就是头信息)最少需要20字节，所以它的负载最多就是1480-20=1460字节。

但由于IP和TCP协议中往往有额外的头信息，所以最终TCP负载实际就是1400字节左右。

因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。(原话)


![](https://user-gold-cdn.xitu.io/2017/12/1/160101f6d6e3eb08?w=681&h=307&f=png&s=7284)

通过上面的学习，我们了解到了IP协议它其实只是一个地址协议，并不能保证包的完整性(也就是如果缓存满了，新进来的包就可能会丢失等等问题)。这时候就需要TCP来知道丢了哪个包，以及如何重新发送这个包。

总结：

1. TCP 协议的作用是：保证数据通信的完整性和可靠性，防止丢包。

2. 以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。


### 二、TCP数据包的编号

可以看到一个包的负载是1400字节，那么如果现在要传输的是大量的数据，那这时候就得分成很多个包。
(比如，一个 10MB 的文件，需要发送7100多个包。)

在进行发送的时候，TCP协议就起作用了，它为每个包编号(sequence number，简称 SEQ),
这样每个包都有了自己的编号后，接受的一方就可以按顺序还原，就算包丢失之后也能知道是哪个包丢失了。

编号规则：

第一个包的编号是一个随机的数字，比如第一个包的编号为1，负载长度为100字节，那么第二个包的编号就是101，依此类推。

这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。

此时我们就可以将TCP协议的作用再补充一条：

将每个要传输的包进行编号，保证数据通信的完整性和可靠性，防止丢包。


### 三、TCP数据包的组装

当TCP协议为每个包编号完成之后，就将TCP数据包发送出去。

在接收到数据包后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。


![](https://user-gold-cdn.xitu.io/2017/12/1/1601074bb215e36d?w=1101&h=323&f=png&s=30516)
可以看到，过程大概就是：
```
编写好的数据包 -->  传递给操作系统 -->  操作系统按照顺序组装 -->
判断TCP数据包中的端口号  --> 继续传递给监听端口号的那个应用程序

```